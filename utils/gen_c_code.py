#!/usr/bin/env python3
##################################################################################
# Author:          Zhantong Zhu
# Acknowledgement: GitHub Copilot + DeepSeek
# Date:            2025-04-11
# Description:     Python script to generate properly indented C code
#################################################################################

import textwrap
import random

class RegisterConfigGenerator:
    def __init__(self):
        self.header = self._generate_header()
        self.includes = self._generate_includes()
        self.regfile_init_code = []
        
    def _generate_header(self):
        return textwrap.dedent("""
            ////////////////////////////////////////////////////////////////////////////////
            // Auto-generated register configuration file
            // Generated by Python register config generator
            ////////////////////////////////////////////////////////////////////////////////\n
        """)
    
    def _generate_includes(self):
        return "#include <stdint.h>\n#include \"init_config.h\"\n\n"

    def init_therm_top_config(self):
        """Generate therm_top config regfile initialization"""
        # Configuration parameters
        # THERM_TOP CONFIG REGFILE 0
        therm_top_start = 0
        therm_top_en = 1
        therm_top_stop = 0
        collect_en = 1
        collect_mode = 0
        pred_en = 0
        pred_mode = 1
        schedule_en = 0
        store_sensor_mode = 0  # 2 bits [9:8]
        action_offset = 4      # 5 bits [14:10]
        num_itr = 10           # 17 bits [31:15]
        sampling_intvl = 200   # 32 bits [63:32]

        # THERM_TOP CONFIG REGFILE 1
        sensor_data_base_addr = 0xF000
        pred_data_base_addr = 0x2000
        action_base_addr = 0x2800

        # THERM_TOP CONFIG REGFILE 2
        npu_input_buf_base_addr = 0x10
        npu_output_buf_base_addr = 0x5

        synthetic_sensor_thermal_encodings = 10
        synthetic_sensor_current_encodings = 20
        synthetic_sensor_voltage_encodings = 30

        # THERM_TOP CONFIG REGFILE 3
        synthetic_action_sequence = 342391
        store_pred_mode = 0     # 2 bits [25:24]
        store_action_mode = 0   # 2 bits [27:26]

        # Calculate register values
        # THERM_TOP CONFIG REGFILE 0
        reg0 = (therm_top_start & 0x1)
        reg0 |= (therm_top_en & 0x1) << 1
        reg0 |= (therm_top_stop & 0x1) << 2
        reg0 |= (collect_en & 0x1) << 3
        reg0 |= (collect_mode & 0x1) << 4
        reg0 |= (pred_en & 0x1) << 5
        reg0 |= (pred_mode & 0x1) << 6
        reg0 |= (schedule_en & 0x1) << 7
        reg0 |= (store_sensor_mode & 0x3) << 8
        reg0 |= (action_offset & 0x1F) << 10
        reg0 |= (num_itr & 0x1FFFF) << 15
        reg0 |= (sampling_intvl & 0xFFFFFFFF) << 32

        # THERM_TOP CONFIG REGFILE 1
        reg1 = (sensor_data_base_addr & 0xFFFFFFFF)         # 32 bits [31:0]
        reg1 |= (pred_data_base_addr & 0xFFFFFFFF) << 32    # 32 bits [63:32]

        # THERM_TOP CONFIG REGFILE 2
        reg2 = 0
        reg2 = (npu_input_buf_base_addr & 0x3FF)                    # 10 bits [9:0]
        reg2 |= (npu_output_buf_base_addr & 0x3FF) << 10            # 10 bits [19:10]
        # Bits [31:20] are reserved and set to 0
        reg2 |= (synthetic_sensor_thermal_encodings & 0xFF) << 32   # 8 bits [39:32]
        reg2 |= (synthetic_sensor_current_encodings & 0xFF) << 40   # 8 bits [47:40]
        reg2 |= (synthetic_sensor_voltage_encodings & 0xFF) << 48   # 8 bits [55:48]
        # Bits [63:56] are reserved and set to 0

        # THERM_TOP CONFIG REGFILE 3
        reg3 = 0
        reg3 |= (synthetic_action_sequence & 0xFFFFFF)      # 24 bits [23:0]
        reg3 |= (store_pred_mode & 0x3) << 24               # 2 bits [25:24]
        reg3 |= (store_action_mode & 0x3) << 26             # 2 bits [27:26]
        # Bits [31:28] are reserved and set to 0
        reg3 |= (action_base_addr & 0xFFFFFFFF) << 32       # 32 bits [63:32]

        therm_top_base_addr = 0x60002218

        # Print the register values for debugging
        print(f"THERM_TOP CONFIG REGFILE 0: Addr: {therm_top_base_addr + 0 * 8:#010x}, Data: {reg0:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 1: Addr: {therm_top_base_addr + 1 * 8:#010x}, Data: {reg1:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 2: Addr: {therm_top_base_addr + 2 * 8:#010x}, Data: {reg2:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 3: Addr: {therm_top_base_addr + 3 * 8:#010x}, Data: {reg3:#018x}")

        therm_top_code = textwrap.indent(textwrap.dedent(f"""
            // THERM_TOP CONFIG REGFILE
            uint64_t *therm_top_base_addr = (uint64_t *)0x60002218;
            *(therm_top_base_addr + 0) = 0x{reg0:016x};
            *(therm_top_base_addr + 1) = 0x{reg1:016x};
            *(therm_top_base_addr + 2) = 0x{reg2:016x};
            *(therm_top_base_addr + 3) = 0x{reg3:016x};
        """), "    ")
        self.regfile_init_code.append(therm_top_code)

    def init_standardization_unit_config(self):
        """Generate standardization unit config regfiles initialization"""
        # Configuration parameters
        num_sensors = 16
        quant_base_addr = 0x60002018
        dequant_base_addr = 0x60002118

        thermal_scale_mult = []
        thermal_scale_shift = []
        thermal_zero_point = []
        power_scale_mult = []
        power_scale_shift = []
        power_zero_point = []
        dequant_scale = []
        dequant_shift = []
        dequant_zero = []
        quant_regfile_data = []
        dequant_regfile_data = []

        for i in range(num_sensors):
            # Temperature quantization - linear progression
            thermal_scale_mult.append(0x0100 + i * 0x0010)      # Start at 1.0 and increase by 0.0625
            thermal_scale_shift.append(0x08 + (i % 3))          # Shift values: 8, 9, 10 repeating
            thermal_zero_point.append(-64 + i * 8)              # Start at -64 and increase by 8

            # Power quantization - different pattern
            power_scale_mult.append(0x0020 + i * 0x0008)        # Start smaller, increase gradually
            power_scale_shift.append(0x06 + (i % 4))            # Shift values: 6-9 repeating
            power_zero_point.append(-32 + i * 4)                # Start at -32 and increase by 4

            # Dequantization - another pattern
            dequant_scale.append(0x0080 + i * 0x0010)           # Start at 0.5, increase by 0.0625
            dequant_shift.append(0x07 + (i % 3))                # Shifts: 7, 8, 9 repeating
            dequant_zero.append(i * 128)                          # Simple progression by 128
    
            # Pack the quantization parameters into a 64-bit register
            quant_data = (thermal_scale_mult[i] & 0xFFFF)           # 16 bits [15:0]
            quant_data |= (thermal_scale_shift[i] & 0xFF) << 16     # 8 bits [23:16]
            quant_data |= (thermal_zero_point[i] & 0xFF) << 24      # 8 bits [31:24]
            quant_data |= (power_scale_mult[i] & 0xFFFF) << 32      # 16 bits [47:32]
            quant_data |= (power_scale_shift[i] & 0xFF) << 48       # 8 bits [55:48]
            quant_data |= (power_zero_point[i] & 0xFF) << 56        # 8 bits [63:56]
            quant_regfile_data.append(quant_data)

            # Print register data for debugging
            print(f"QUANT CONFIG REGFILE {i}: Addr: {quant_base_addr + i * 8:#010x}, Data: {quant_data:#018x}")

            # Pack the dequantization parameters into a 64-bit register
            dequant_data = (dequant_scale[i] & 0xFFFF)              # 16 bits [15:0]
            dequant_data |= (dequant_shift[i] & 0xFF) << 16         # 8 bits [23:16]
            dequant_data |= (dequant_zero[i] & 0xFFFFFFFF) << 24          # 32 bits [55:24]
            dequant_regfile_data.append(dequant_data)

            # Print register data for debugging
            print(f"DEQUANT CONFIG REGFILE {i}: Addr: {dequant_base_addr + i * 8:#010x}, Data: {dequant_data:#018x}")

        # Generate CONFIG REGFILE BASE ADDR
        standardization_code = textwrap.indent(textwrap.dedent(f"""
            // Standardization Unit CONFIG REGFILE
            uint64_t *quant_base = (uint64_t *)0x{quant_base_addr:08x};
            uint64_t *dequant_base = (uint64_t *)0x{dequant_base_addr:08x};\n
        """), "    ")

        # Generate QUANT REGFILE DATA
        for i in range(num_sensors):
            standardization_code += f"    *(quant_base + {i}) = 0x{quant_regfile_data[i]:016x};\n"

        # Generate DEQUANT REGFILE DATA
        for i in range(num_sensors):
            standardization_code += f"    *(dequant_base + {i}) = 0x{dequant_regfile_data[i]:016x};\n"

        self.regfile_init_code.append(standardization_code)

    def init_q_table_config(self):
        """Generate Q-table configuration initialization"""
        num_states = 512
        num_actions = 8
        q_table_0_base_addr = 0x60000018
        q_table_1_base_addr = 0x60001018

        q_table_0_value = []
        q_table_1_value = []

        for i in range(num_states):
            curr_q_value = 0
            for j in range (num_actions):
                mod_value = (i + j) % 4
                if mod_value == 0:
                    curr_q_value |= ((0x0100 + 2 * i + j * 0x0020) & 0xFFFF) << ( j * 16)
                elif mod_value == 1:
                    curr_q_value |= ((0xFF00 - i - j * 0x0025) & 0xFFFF) << ( j * 16)
                elif mod_value == 2:
                    curr_q_value |= ((0x0000) & 0xFFFF) << (j * 16)
                elif mod_value == 3:
                    curr_q_value |= ((0x0080 + i + j * 0x0010) & 0xFFFF) << (j * 16)
            q_table_0_value.append((curr_q_value & 0xFFFFFFFFFFFFFFFF))
            q_table_1_value.append((curr_q_value >> 64) & 0xFFFFFFFFFFFFFFFF)
        # Generate Q-Table 0
        q_table_code = textwrap.indent(textwrap.dedent(f"""
            // Q-Table 0 Initialization
            uint64_t *q_table_0_base = (uint64_t *)0x{q_table_0_base_addr:08x};
        """), "    ")
        for i in range(num_states):
            q_table_code += f"    *(q_table_0_base + {i}) = 0x{q_table_0_value[i]:016x};\n"

            # Print register data for debugging
            print (f"Q-Table 0 at index {i}: Addr: {q_table_0_base_addr + i * 8:#010x}, Data: {q_table_0_value[i]:#018x}")
        
        # Generate Q-Table 1
        q_table_code += textwrap.indent(textwrap.dedent(f"""
            // Q-Table 1 Initialization
            uint64_t *q_table_1_base = (uint64_t *)0x{q_table_1_base_addr:08x};
        """), "    ")
        for i in range(num_states):
            q_table_code += f"    *(q_table_1_base + {i}) = 0x{q_table_1_value[i]:016x};\n"

            # Print register data for debugging
            print (f"Q-Table 1 at index {i}: Addr: {q_table_1_base_addr + i * 8:#010x}, Data: {q_table_1_value[i]:#018x}")
        
        self.regfile_init_code.append(q_table_code)

    def init_sensor_collection_unit_config(self):
        """Generate sensor collection unit configuration initialization"""
        random.seed(42)  # For reproducibility

        # Define constants (adjust as needed for your system)
        WEIGHT_T_NUM = 6
        WEIGHT_V_NUM = 6
        WEIGHT_I_NUM = 10
        NUM_SENSORS = 14
        LOG_OUTPUT_WIDTH = 11  # 11-bit width

        # Base addresses will be filled in later
        weight_buffer_base_addr = 0x60002238  # Placeholder - will be replaced
        sensor_freq_buffer_base_addr = 0x60002338  # Placeholder - will be replaced

        # Initialize arrays for weights and frequencies
        sensor_T_weight_values = []
        sensor_V_weight_values = []
        sensor_I_weight_values = []
        freq_0_values = []
        freq_1_values = []
        freq_2_values = []

        # Generate synthetic weight values
        for i in range(WEIGHT_T_NUM):
            case = i % 5
            if case == 0:
                sensor_T_weight_values.append(0x00000001)  # Minimum
            elif case == 1:
                sensor_T_weight_values.append(0xFFFFFFFF)  # Maximum
            elif case == 2:
                sensor_T_weight_values.append(0x55555555)  # Alternating bits
            elif case == 3:
                sensor_T_weight_values.append(0x80000000)  # MSB set
            elif case == 4:
                sensor_T_weight_values.append(random.randint(0, 0xFFFFFFFF))  # Random

        for i in range(WEIGHT_V_NUM):
            case = (i + 2) % 5
            if case == 0:
                sensor_V_weight_values.append(0x00000001)  # Minimum
            elif case == 1:
                sensor_V_weight_values.append(0xFFFFFFFF)  # Maximum
            elif case == 2:
                sensor_V_weight_values.append(0xAAAAAAAA)  # Alternating bits (inverse)
            elif case == 3:
                sensor_V_weight_values.append(0x00000080)  # Byte MSB set
            elif case == 4:
                sensor_V_weight_values.append(random.randint(0, 0xFFFFFFFF))  # Random

        for i in range(WEIGHT_I_NUM):
            case = (i + 4) % 5
            if case == 0:
                sensor_I_weight_values.append(0x00010001)  # Pattern
            elif case == 1:
                sensor_I_weight_values.append(0xFFFE0001)  # Edge case
            elif case == 2:
                sensor_I_weight_values.append(0x01010101)  # Repeating pattern
            elif case == 3:
                sensor_I_weight_values.append(1 << i)  # Powers of 2
            elif case == 4:
                sensor_I_weight_values.append(random.randint(0, 0xFFFFFFFF))  # Random

        # Generate synthetic frequency values with correct bit widths
        for i in range(NUM_SENSORS):
            case = i % 6
            if case == 0:  # Zero case
                freq_0_values.append(0)
                freq_1_values.append(0)
                freq_2_values.append(0)
            elif case == 1:  # Maximum values
                freq_0_values.append((1 << (LOG_OUTPUT_WIDTH-1)) - 1)  # Max for freq_0 (10 bits)
                freq_1_values.append((1 << LOG_OUTPUT_WIDTH) - 1)      # Max for freq_1 (11 bits)
                freq_2_values.append((1 << LOG_OUTPUT_WIDTH) - 1)      # Max for freq_2 (11 bits)
            elif case == 2:  # Alternating bit patterns
                freq_0_values.append((2**(LOG_OUTPUT_WIDTH-1) - 1) & 0xAAA)  # 10-bit mask
                freq_1_values.append((2**LOG_OUTPUT_WIDTH - 1) & 0x555)      # 11-bit mask
                freq_2_values.append((2**LOG_OUTPUT_WIDTH - 1) & 0xAAA)      # 11-bit mask
            elif case == 3:  # Single bit set
                freq_0_values.append(1 << (i % (LOG_OUTPUT_WIDTH-1)))        # Ensure within 10 bits
                freq_1_values.append(1 << (i % LOG_OUTPUT_WIDTH))            # Ensure within 11 bits
                freq_2_values.append(1 << ((i+3) % LOG_OUTPUT_WIDTH))        # Ensure within 11 bits
            elif case == 4:  # Scaled by sensor index
                freq_0_values.append((i * 100) % (1 << (LOG_OUTPUT_WIDTH-1)))  # Modulo 2^10
                freq_1_values.append((i * 200) % (1 << LOG_OUTPUT_WIDTH))       # Modulo 2^11
                freq_2_values.append((i * 300) % (1 << LOG_OUTPUT_WIDTH))       # Modulo 2^11
            elif case == 5:  # Random values
                freq_0_values.append(random.randint(0, (1 << (LOG_OUTPUT_WIDTH-1)) - 1))  # Random 0-1023 (10 bits)
                freq_1_values.append(random.randint(0, (1 << LOG_OUTPUT_WIDTH) - 1))     # Random 0-2047 (11 bits)
                freq_2_values.append(random.randint(0, (1 << LOG_OUTPUT_WIDTH) - 1))     # Random 0-2047 (11 bits)

        print("Configuring sensor collection unit constants...")

        # Generate C code for initialization
        sensor_config_code = textwrap.indent(textwrap.dedent(f"""
            // Sensor Collection Unit Configuration
            uint64_t *weight_buffer = (uint64_t *)0x{weight_buffer_base_addr:08x};
            uint64_t *freq_buffer = (uint64_t *)0x{sensor_freq_buffer_base_addr:08x};

            // Initialize sensor weight buffers
            // Current (I) weights
        """), "    ")

        # Write I weights
        for i in range(WEIGHT_I_NUM):
            weight_value = sensor_I_weight_values[i]
            sensor_config_code += f"    *(weight_buffer + {i}) = 0x{weight_value:08x}ULL;  // I weight {i}\n"
            print(f"WEIGHT_I buffer {i}: Addr: {weight_buffer_base_addr + i * 8:#010x}, Data: 0x{weight_value:08x}")

        sensor_config_code += "    // Voltage (V) weights\n"
        # Write V weights
        for i in range(WEIGHT_V_NUM):
            idx = WEIGHT_I_NUM + i
            weight_value = sensor_V_weight_values[i]
            sensor_config_code += f"    *(weight_buffer + {idx}) = 0x{weight_value:08x}ULL;  // V weight {i}\n"
            print(f"WEIGHT_V buffer {i}: Addr: {weight_buffer_base_addr + idx * 8:#010x}, Data: 0x{weight_value:08x}")

        sensor_config_code += "    // Temperature (T) weights\n"
        # Write T weights
        for i in range(WEIGHT_T_NUM):
            idx = WEIGHT_I_NUM + WEIGHT_V_NUM + i
            weight_value = sensor_T_weight_values[i]
            sensor_config_code += f"    *(weight_buffer + {idx}) = 0x{weight_value:08x}ULL;  // T weight {i}\n"
            print(f"WEIGHT_T buffer {i}: Addr: {weight_buffer_base_addr + idx * 8:#010x}, Data: 0x{weight_value:08x}")

        sensor_config_code += "\n    // Initialize sensor frequency buffers\n"
        # Write frequency values with proper bit masks
        for i in range(NUM_SENSORS):
            # Ensure values are properly masked to their bit widths
            f0 = freq_0_values[i] & 0x3FF              # 10 bits for freq_0
            f1 = freq_1_values[i] & 0x7FF              # 11 bits for freq_1
            f2 = freq_2_values[i] & 0x7FF              # 11 bits for freq_2

            # Pack the three frequency values into one 64-bit value with proper spacing
            freq_data = f0 | (f1 << 10) | (f2 << 21)

            sensor_config_code += f"    *(freq_buffer + {i}) = 0x{freq_data:016x}ULL;  // Frequencies for sensor {i}\n"
            print(f"FREQ buffer {i}: Addr: {sensor_freq_buffer_base_addr + i * 8:#010x}, Data: 0x{freq_data:016x}")

        print("Sensor collection unit constants configured")
        self.regfile_init_code.append(sensor_config_code)

    def init_rl_scheduler_config(self):
        """Generate RL scheduler configuration with proper indentation"""
        # RL config regfile 0
        coef_k1 = 0x1000
        coef_k2 = 0x0800
        coef_k3 = 0x0400
        coef_frac_bits = 12
        learning_rate = 0x0100

        # RL config regfile 1
        discount_factor = 0x0200
        initial_epsilon = 0x0F00
        num_active_actions = 8
        thres_high = 0x50
        thres_mid = 0x30
        thres_low = 0x10

        # RL config regfile 2
        epsilon_decay_step = 0x00CC
        epsilon_min = 0x0005
        epsilon_decay_factor = 0x000A
        epsilon_decay_interval = 0x10
        epsilon_decay_mode = 0

        # Calculate register values
        # RL CONFIG REGFILE 0
        reg0 = (coef_k1 & 0xFFFF)
        reg0 |= (coef_k2 & 0xFFFF) << 16
        reg0 |= (coef_k3 & 0xFFFF) << 32
        reg0 |= (learning_rate & 0xFFFF) << 48

        # RL CONFIG REGFILE 1
        reg1 = (discount_factor & 0xFFFF)
        reg1 |= (initial_epsilon & 0xFFFF) << 16
        reg1 |= (num_active_actions & 0xFF) << 32
        reg1 |= (thres_high & 0xFF) << 40
        reg1 |= (thres_mid & 0xFF) << 48
        reg1 |= (thres_low & 0xFF) << 56

        # RL CONFIG REGFILE 2
        reg2 = (epsilon_decay_step & 0xFFFF)
        reg2 |= (epsilon_min & 0xFFFF) << 16
        reg2 |= (epsilon_decay_factor & 0xFFFF) << 32
        reg2 |= (epsilon_decay_interval & 0xFF) << 48
        reg2 |= (epsilon_decay_mode & 0x3) << 56
        reg2 |= (coef_frac_bits & 0xF) << 57

        # Print the register values for debugging
        rl_config_base_addr = 0x60000000
        print(f"RL CONFIG REGFILE 0: Addr: {rl_config_base_addr + 0 * 8:#010x}, Data: {reg0:#018x}")
        print(f"RL CONFIG REGFILE 1: Addr: {rl_config_base_addr + 1 * 8:#010x}, Data: {reg1:#018x}")
        print(f"RL CONFIG REGFILE 2: Addr: {rl_config_base_addr + 2 * 8:#010x}, Data: {reg2:#018x}")

        # Generate C code
        rl_scheduler_code = textwrap.indent(textwrap.dedent(f"""
            // RL Scheduler CONFIG REGFILE
            uint64_t *rl_base_addr = (uint64_t *)0x60000000;
            *(rl_base_addr + 0) = 0x{reg0:016x};  // RL config regfile 0
            *(rl_base_addr + 1) = 0x{reg1:016x};  // RL config regfile 1
            *(rl_base_addr + 2) = 0x{reg2:016x};  // RL config regfile 2
        """), "    ")
        self.regfile_init_code.append(rl_scheduler_code)

    def start_tensor_engine_wrapper(self):
        """Start tensor engine wrapper"""
        num_actions = 8
        num_instr_per_action = 4

        loop_op = 1
        local_read = 1
        l_r_op = 1
        func = 0
        cim_addr = 0
        gbuffer_addr = 0
        op_cycle = 0
        tensor_engine_instr = []
        tensor_engine_config = 0b1_0000_0000_0000_0100_0000_0001
        tensor_engine_config_addr = 0x0000_0000_4200_0000
        tensor_engine_instr_base_addr = 0x0000_0000_4100_0000

        # Generate tensor engine instructions
        for i in range(num_actions * num_instr_per_action):
            func = i % 8
            cim_addr = i % 512
            curr_tensor_engine_instr = (op_cycle & 0xF)             # 4 bits [3:0]
            curr_tensor_engine_instr |= (gbuffer_addr & 0xFFF) << 4 # 12 bits [15:4]
            curr_tensor_engine_instr |= (cim_addr & 0x1FF) << 16    # 9 bits [24:16]
            curr_tensor_engine_instr |= (func & 0x7) << 25          # 3 bits [27:25]
            curr_tensor_engine_instr |= (l_r_op & 0x3) << 28        # 2 bits [29:28]
            curr_tensor_engine_instr |= (local_read & 0x1) << 30    # 1 bit [30]
            curr_tensor_engine_instr |= (loop_op & 0x1) << 31       # 1 bit [31]
            curr_tensor_engine_instr |= 0x0 << 32                   # 1 bit [32]
            tensor_engine_instr.append(curr_tensor_engine_instr)

        start_code = textwrap.indent(textwrap.dedent(f"""
            // Start tensor_engine_wrapper
            uint64_t *tensor_engine_config_addr = (uint64_t *)0x{tensor_engine_config_addr:016x};
            uint64_t *tensor_engine_instr_base_addr = (uint64_t *)0x{tensor_engine_instr_base_addr:016x};

            // Tensor engine wrapper config
            *(tensor_engine_config_addr) = 0x{tensor_engine_config:016x};
        """), "    ")
    
        for i in range (num_actions * num_instr_per_action):
            start_code += f"    *(tensor_engine_instr_base_addr + {i}) = 0x{tensor_engine_instr[i]:016x};\n"

            # Print register data for debugging
            print(f"TENSOR_ENGINE INSTRUCTION {i}: Addr: {tensor_engine_instr_base_addr + i * 8:#010x}, Data: {tensor_engine_instr[i]:#018x}")

        print (f"TENSOR_ENGING CONFIG: Addr: {tensor_engine_config_addr:#010x}, Data: {tensor_engine_config:#018x}")
        self.regfile_init_code.append(start_code)

    def _generate_main_function(self):
        """Generate main function"""
        init_code = "\n".join(self.regfile_init_code)
        main_func_code = "void init_config(void) {\n"
        main_func_code += textwrap.indent(init_code, "")
        main_func_code += "\n    return;\n"
        main_func_code += "}\n"
        return main_func_code

    def generate_c_file(self, filename="/home/bwoah/tools/C_compile_template/src/init_config.c"):
        """Generate the complete C source file"""
        with open(filename, "w") as f:
            f.write(self.header)
            f.write(self.includes)
            f.write(self._generate_main_function())
        
        print(f"Successfully generated {filename}")

def main():
    generator = RegisterConfigGenerator()
    
    generator.init_standardization_unit_config()
    generator.init_rl_scheduler_config()
    generator.init_sensor_collection_unit_config()
    generator.init_q_table_config()
    # generator.init_therm_top_config()

    # generator.start_tensor_engine_wrapper()

    generator.generate_c_file()

if __name__ == "__main__":
    main()
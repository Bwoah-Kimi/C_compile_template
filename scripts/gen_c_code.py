#!/usr/bin/env python3
##################################################################################
# Author:          Zhantong Zhu
# Acknowledgement: GitHub Copilot + DeepSeek
# Date:            2025-04-11
# Description:     Python script to generate properly indented C code
#################################################################################

import textwrap

class RegisterConfigGenerator:
    def __init__(self):
        self.header = self._generate_header()
        self.includes = self._generate_includes()
        self.regfile_init_code = []
        
    def _generate_header(self):
        return textwrap.dedent("""
            ////////////////////////////////////////////////////////////////////////////////
            // Auto-generated register configuration file
            // Generated by Python register config generator
            ////////////////////////////////////////////////////////////////////////////////\n
        """)
    
    def _generate_includes(self):
        return "#include <stdint.h>\n\n"
    
    def init_therm_top_config(self):
        """Generate therm_top config regfile initialization"""
        # Configuration parameters
        therm_top_start = 0
        therm_top_en = 1
        # THERM_TOP CONFIG REGFILE 0
        therm_top_stop = 0
        collect_en = 1
        collect_mode = 0
        pred_en = 0
        schedule_en = 0
        store_sensor_en = 1
        store_pred_en = 0
        store_action_en = 0
        action_offset = 4
        num_itr = 10
        sampling_intvl = 200

        # THERM_TOP CONFIG REGFILE 1
        sensor_data_base_addr = 0x0200
        pred_data_base_addr = 0x2000
        action_base_addr = 0x2800

        # THERM_TOP CONFIG REGFILE 2
        npu_input_buf_base_addr = 0x10
        npu_output_buf_base_addr = 0x5

        synthetic_sensor_thermal_encodings = 0x10
        synthetic_sensor_current_encodings = 0x20
        synthetic_sensor_voltage_encodings = 0x30

        # THERM_TOP CONFIG REGFILE 3
        synthetic_action_sequence =  342391

        # Calculate register values
        # THERM_TOP CONFIG REGFILE 0
        reg0 = (therm_top_start & 0x1)
        reg0 |= (therm_top_en & 0x1) << 1
        reg0 |= (therm_top_stop & 0x1) << 2
        reg0 |= (collect_en & 0x1) << 3
        reg0 |= (collect_mode & 0x1) << 4
        reg0 |= (pred_en & 0x1) << 5
        reg0 |= (schedule_en & 0x1) << 6
        reg0 |= (store_sensor_en & 0x1) << 7
        reg0 |= (store_pred_en & 0x1) << 8
        reg0 |= (store_action_en & 0x1) << 9
        reg0 |= (action_offset & 0x1F) << 10
        reg0 |= (num_itr & 0x1FFFF) << 15
        reg0 |= (sampling_intvl & 0xFFFFFFFF) << 32

        # THERM_TOP CONFIG REGFILE 1
        reg1 = (action_base_addr & 0xFFFF)
        reg1 |= (sensor_data_base_addr & 0xFFFF) << 16
        reg1 |= (pred_data_base_addr & 0xFFFF) << 32

        # THERM_TOP CONFIG REGFILE 2
        reg2 = (npu_input_buf_base_addr & 0x3FF)                    # 10 bits [9:0]
        reg2 |= (npu_output_buf_base_addr & 0x3FF) << 10            # 10 bits [19:10]
        # Bits [31:20] are reserved and set to 0
        reg2 |= (synthetic_sensor_thermal_encodings & 0xFF) << 32   # 8 bits [39:32]
        reg2 |= (synthetic_sensor_current_encodings & 0xFF) << 40   # 8 bits [47:40]
        reg2 |= (synthetic_sensor_voltage_encodings & 0xFF) << 48   # 8 bits [55:48]
        # Bits [63:56] are reserved and set to 0

        # THERM_TOP CONFIG REGFILE 3
        reg3 = (synthetic_action_sequence & 0xFFFFFF)    # 24 bits [23:0]
        # Bits [63:24] are reserved and set to 0

        # Print the register values for debugging
        print(f"THERM_TOP CONFIG REGFILE 0: {reg0:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 1: {reg1:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 2: {reg2:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 3: {reg3:#018x}")

        therm_top_code = textwrap.indent(textwrap.dedent(f"""
            // THERM_TOP CONFIG REGFILE
            uint64_t *therm_top_base_addr = (uint64_t *)0x60002218;
            *(therm_top_base_addr + 0) = 0x{reg0:016x};
            *(therm_top_base_addr + 1) = 0x{reg1:016x};
            *(therm_top_base_addr + 2) = 0x{reg2:016x};
            *(therm_top_base_addr + 3) = 0x{reg3:016x};
        """), "    ")
        self.regfile_init_code.append(therm_top_code)

    def init_standardization_unit_config(self):
        """Generate standardization unit config regfiles initialization"""
        # Configuration parameters
        num_sensors = 16
        quant_base_addr = 0x60002018
        dequant_base_addr = 0x60002118

        thermal_scale_mult = []
        thermal_scale_shift = []
        thermal_zero_point = []
        power_scale_mult = []
        power_scale_shift = []
        power_zero_point = []
        dequant_scale = []
        dequant_shift = []
        dequant_zero = []
        quant_regfile_data = []
        dequant_regfile_data = []

        for i in range(num_sensors):
            thermal_scale_mult.append(0x0100 + i)
            thermal_scale_shift.append(i)
            thermal_zero_point.append(40 + i)
            power_scale_mult.append(0x0200 + i)
            power_scale_shift.append(10 + i)
            power_zero_point.append(20 + i)

            quant_data = (thermal_scale_mult[i] & 0xFFFF)           # 16 bits [15:0]
            quant_data |= (thermal_scale_shift[i] & 0xFF) << 16     # 8 bits [23:16]
            quant_data |= (thermal_zero_point[i] & 0xFF) << 24      # 8 bits [31:24]
            quant_data |= (power_scale_mult[i] & 0xFFFF) << 32      # 16 bits [47:32]
            quant_data |= (power_scale_shift[i] & 0xFF) << 48       # 8 bits [55:48]
            quant_data |= (power_zero_point[i] & 0xFF) << 56        # 8 bits [63:56]
            quant_regfile_data.append(quant_data)

            # Print register data for debugging
            print(f"QUANT CONFIG REGFILE {i}: {quant_data:#018x}")

        for i in range(num_sensors):
            dequant_scale.append(0x00C0 + i)
            dequant_shift.append(6 + i)
            dequant_zero.append(120 + i)

            dequant_data = (dequant_scale[i] & 0xFFFF)              # 16 bits [15:0]
            dequant_data |= (dequant_shift[i] & 0xFF) << 16         # 8 bits [23:16]
            dequant_data |= (dequant_zero[i] & 0xFF) << 24          # 8 bits [31:24]
            dequant_regfile_data.append(dequant_data)

            # Print register data for debugging
            print(f"DEQUANT CONFIG REGFILE {i}: {dequant_data:#018x}")

        # Generate CONFIG REGFILE BASE ADDR
        standardization_code = textwrap.indent(textwrap.dedent(f"""
            // Standardization Unit CONFIG REGFILE
            uint64_t *quant_base = (uint64_t *)0x{quant_base_addr:08x};
            uint64_t *dequant_base = (uint64_t *)0x{dequant_base_addr:08x};\n
        """), "    ")
        # Generate QUANT REGFILE DATA
        for i in range(num_sensors):
            standardization_code += f"    *(quant_base + {i}) = 0x{quant_regfile_data[i]:016x};\n"

        # Generate DEQUANT REGFILE DATA
        for i in range(num_sensors):
            standardization_code += f"    *(dequant_base + {i}) = 0x{dequant_regfile_data[i]:016x};\n"

        self.regfile_init_code.append(standardization_code)

    def init_q_table_config(self):
        """Generate Q-table configuration initialization"""
        num_states = 512
        num_actions = 8
        q_table_0_base_addr = 0x60000018
        q_table_1_base_addr = 0x60001018

        q_table_value = []

        for i in range(num_states):
            for j in range (num_actions):
                mod_value = (i + j) % 4
                if mod_value == 0:
                    q_table_value.append(0x0100 + 2 * i + j * 0x0020)
                elif mod_value == 1:
                    q_table_value.append(0xFF00 - i - j * 0x0025)
                elif mod_value == 2:
                    q_table_value.append(0x0000)
                elif mod_value == 3:
                    q_table_value.append(0x0080 + i + j * 0x0010)
                
        # Generate Q-Table 0
        q_table_code = textwrap.indent(textwrap.dedent(f"""
            // Q-Table 0 Initialization
            uint64_t *q_table_0_base = (uint64_t *)0x{q_table_0_base_addr:08x};
        """), "    ")
        for i in range(num_states):
            q_table_code += f"    *(q_table_0_base + {i}) = 0x{q_table_value[i]:016x};\n"

            # Print register data for debugging
            print (f"Q-Table 0 at index {i}: {q_table_value[i]:#018x}")
        
        # Generate Q-Table 1
        q_table_code += textwrap.indent(textwrap.dedent(f"""
            // Q-Table 1 Initialization
            uint64_t *q_table_1_base = (uint64_t *)0x{q_table_1_base_addr:08x};
        """), "    ")
        for i in range(num_states):
            q_table_code += f"    *(q_table_1_base + {i}) = 0x{q_table_value[i]:016x};\n"

            # Print register data for debugging
            print (f"Q-Table 1 at index {i}: {q_table_value[i]:#018x}")
        
        self.regfile_init_code.append(q_table_code)

    def init_rl_scheduler_config(self):
        """Generate RL scheduler configuration with proper indentation"""
        # RL config regfile 0
        coef_k1 = 0x1000
        coef_k2 = 0x0800
        coef_k3 = 0x0400
        learning_rate = 0x0100

        # RL config regfile 1
        discount_factor = 0x0200
        initial_epsilon = 0x0F00
        num_active_actions = 8
        thres_high = 0x50
        thres_mid = 0x30
        thres_low = 0x10

        # RL config regfile 2
        epsilon_decay_step = 0x00CC
        epsilon_min = 0x0005
        epsilon_decay_factor = 0x000A
        epsilon_decay_interval = 0x10
        epsilon_decay_mode = 0

        # Calculate register values
        # RL CONFIG REGFILE 0
        reg0 = (coef_k1 & 0xFFFF)
        reg0 |= (coef_k2 & 0xFFFF) << 16
        reg0 |= (coef_k3 & 0xFFFF) << 32
        reg0 |= (learning_rate & 0xFFFF) << 48

        # RL CONFIG REGFILE 1
        reg1 = (discount_factor & 0xFFFF)
        reg1 |= (initial_epsilon & 0xFFFF) << 16
        reg1 |= (num_active_actions & 0xFF) << 32
        reg1 |= (thres_high & 0xFF) << 40
        reg1 |= (thres_mid & 0xFF) << 48
        reg1 |= (thres_low & 0xFF) << 56

        # RL CONFIG REGFILE 2
        reg2 = (epsilon_decay_step & 0xFFFF)
        reg2 |= (epsilon_min & 0xFFFF) << 16
        reg2 |= (epsilon_decay_factor & 0xFFFF) << 32
        reg2 |= (epsilon_decay_interval & 0xFF) << 48
        reg2 |= (epsilon_decay_mode & 0x3) << 56

        # Print the register values for debugging
        print(f"RL CONFIG REGFILE 0: {reg0:#018x}")
        print(f"RL CONFIG REGFILE 1: {reg1:#018x}")
        print(f"RL CONFIG REGFILE 2: {reg2:#018x}")

        # Generate C code
        rl_scheduler_code = textwrap.indent(textwrap.dedent(f"""
            // RL Scheduler CONFIG REGFILE
            uint64_t *rl_base_addr = (uint64_t *)0x60000000;
            *(rl_base_addr + 0) = 0x{reg0:016x};  // RL config regfile 0
            *(rl_base_addr + 1) = 0x{reg1:016x};  // RL config regfile 1
            *(rl_base_addr + 2) = 0x{reg2:016x};  // RL config regfile 2
        """), "    ")
        self.regfile_init_code.append(rl_scheduler_code)

    def _generate_main_function(self):
        """Generate main function"""
        init_code = "\n".join(self.regfile_init_code)
        main_func_code = "int main(void) {\n"
        main_func_code += textwrap.indent(init_code, "")
        main_func_code += textwrap.indent("\nwhile (1) {\n", "    ")
        main_func_code += textwrap.indent("}\n", "    ")
        main_func_code += "\n    return 0;\n"
        main_func_code += "}\n"
        return main_func_code

    def generate_c_file(self, filename="../src/main.c"):
        """Generate the complete C source file"""
        with open(filename, "w") as f:
            f.write(self.header)
            f.write(self.includes)
            f.write(self._generate_main_function())
        
        print(f"Successfully generated {filename}")

def main():
    generator = RegisterConfigGenerator()
    generator.init_therm_top_config()
    generator.init_standardization_unit_config()
    generator.init_rl_scheduler_config()
    generator.init_q_table_config()
    generator.generate_c_file()

if __name__ == "__main__":
    main()
#!/usr/bin/env python3
##################################################################################
# Author:          Zhantong Zhu
# Acknowledgement: GitHub Copilot + DeepSeek
# Date:            2025-04-11
# Description:     Python script to generate properly indented C code
#################################################################################

import textwrap

class RegisterConfigGenerator:
    def __init__(self):
        self.header = self._generate_header()
        self.includes = self._generate_includes()
        self.regfile_init_code = []
        
    def _generate_header(self):
        return textwrap.dedent("""
            ////////////////////////////////////////////////////////////////////////////////
            // Auto-generated register configuration file
            // Generated by Python register config generator
            ////////////////////////////////////////////////////////////////////////////////\n
        """)
    
    def _generate_includes(self):
        return "#include <stdint.h>\n\n"

    def init_therm_top_config(self):
        """Generate therm_top config regfile initialization"""
        # Configuration parameters
        # THERM_TOP CONFIG REGFILE 0
        therm_top_start = 0
        therm_top_en = 1
        therm_top_stop = 0
        collect_en = 1
        collect_mode = 0
        pred_en = 0
        schedule_en = 0
        store_sensor_en = 1
        store_pred_en = 0
        store_action_en = 0
        action_offset = 4
        num_itr = 10
        sampling_intvl = 200

        # THERM_TOP CONFIG REGFILE 1
        sensor_data_base_addr = 0xF000
        pred_data_base_addr = 0x2000
        action_base_addr = 0x2800

        # THERM_TOP CONFIG REGFILE 2
        npu_input_buf_base_addr = 0x10
        npu_output_buf_base_addr = 0x5

        synthetic_sensor_thermal_encodings = 10
        synthetic_sensor_current_encodings = 20
        synthetic_sensor_voltage_encodings = 30

        # THERM_TOP CONFIG REGFILE 3
        synthetic_action_sequence =  342391

        # Calculate register values
        # THERM_TOP CONFIG REGFILE 0
        reg0 = (therm_top_start & 0x1)
        reg0 |= (therm_top_en & 0x1) << 1
        reg0 |= (therm_top_stop & 0x1) << 2
        reg0 |= (collect_en & 0x1) << 3
        reg0 |= (collect_mode & 0x1) << 4
        reg0 |= (pred_en & 0x1) << 5
        reg0 |= (schedule_en & 0x1) << 6
        reg0 |= (store_sensor_en & 0x1) << 7
        reg0 |= (store_pred_en & 0x1) << 8
        reg0 |= (store_action_en & 0x1) << 9
        reg0 |= (action_offset & 0x1F) << 10
        reg0 |= (num_itr & 0x1FFFF) << 15
        reg0 |= (sampling_intvl & 0xFFFFFFFF) << 32

        # THERM_TOP CONFIG REGFILE 1
        reg1 = (sensor_data_base_addr & 0xFFFFFFFF)         # 32 bits [31:0]
        reg1 |= (pred_data_base_addr & 0xFFFFFFFF) << 32    # 32 bits [63:32]

        # THERM_TOP CONFIG REGFILE 2
        reg2 = 0
        reg2 = (npu_input_buf_base_addr & 0x3FF)                    # 10 bits [9:0]
        reg2 |= (npu_output_buf_base_addr & 0x3FF) << 10            # 10 bits [19:10]
        # Bits [31:20] are reserved and set to 0
        reg2 |= (synthetic_sensor_thermal_encodings & 0xFF) << 32   # 8 bits [39:32]
        reg2 |= (synthetic_sensor_current_encodings & 0xFF) << 40   # 8 bits [47:40]
        reg2 |= (synthetic_sensor_voltage_encodings & 0xFF) << 48   # 8 bits [55:48]
        # Bits [63:56] are reserved and set to 0

        # THERM_TOP CONFIG REGFILE 3
        reg3 = 0
        reg3 |= (synthetic_action_sequence & 0xFFFFFF)      # 24 bits [23:0]
        # Bits [31:24] are reserved and set to 0
        reg3 |= (action_base_addr & 0xFFFFFFFF) << 32       # 32 bits [63:32]

        therm_top_base_addr = 0x60002218
        # Print the register values for debugging
        print(f"THERM_TOP CONFIG REGFILE 0: Addr: {therm_top_base_addr + 0 * 8:#010x}, Data: {reg0:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 1: Addr: {therm_top_base_addr + 1 * 8:#010x}, Data: {reg1:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 2: Addr: {therm_top_base_addr + 2 * 8:#010x}, Data: {reg2:#018x}")
        print(f"THERM_TOP CONFIG REGFILE 3: Addr: {therm_top_base_addr + 3 * 8:#010x}, Data: {reg3:#018x}")

        therm_top_code = textwrap.indent(textwrap.dedent(f"""
            // THERM_TOP CONFIG REGFILE
            uint64_t *therm_top_base_addr = (uint64_t *)0x60002218;
            *(therm_top_base_addr + 0) = 0x{reg0:016x};
            *(therm_top_base_addr + 1) = 0x{reg1:016x};
            *(therm_top_base_addr + 2) = 0x{reg2:016x};
            *(therm_top_base_addr + 3) = 0x{reg3:016x};
        """), "    ")
        self.regfile_init_code.append(therm_top_code)

    def init_standardization_unit_config(self):
        """Generate standardization unit config regfiles initialization"""
        # Configuration parameters
        num_sensors = 16
        quant_base_addr = 0x60002018
        dequant_base_addr = 0x60002118

        thermal_scale_mult = []
        thermal_scale_shift = []
        thermal_zero_point = []
        power_scale_mult = []
        power_scale_shift = []
        power_zero_point = []
        dequant_scale = []
        dequant_shift = []
        dequant_zero = []
        quant_regfile_data = []
        dequant_regfile_data = []

        for i in range(num_sensors):
            thermal_scale_mult.append(0x0100 + i)
            thermal_scale_shift.append(i)
            thermal_zero_point.append(40 + i)
            power_scale_mult.append(0x0200 + i)
            power_scale_shift.append(10 + i)
            power_zero_point.append(20 + i)

            quant_data = (thermal_scale_mult[i] & 0xFFFF)           # 16 bits [15:0]
            quant_data |= (thermal_scale_shift[i] & 0xFF) << 16     # 8 bits [23:16]
            quant_data |= (thermal_zero_point[i] & 0xFF) << 24      # 8 bits [31:24]
            quant_data |= (power_scale_mult[i] & 0xFFFF) << 32      # 16 bits [47:32]
            quant_data |= (power_scale_shift[i] & 0xFF) << 48       # 8 bits [55:48]
            quant_data |= (power_zero_point[i] & 0xFF) << 56        # 8 bits [63:56]
            quant_regfile_data.append(quant_data)

            # Print register data for debugging
            print(f"QUANT CONFIG REGFILE {i}: Addr: {quant_base_addr + i * 8:#010x}, Data: {quant_data:#018x}")

        for i in range(num_sensors):
            dequant_scale.append(0x00C0 + i)
            dequant_shift.append(6 + i)
            dequant_zero.append(120 + i)

            dequant_data = (dequant_scale[i] & 0xFFFF)              # 16 bits [15:0]
            dequant_data |= (dequant_shift[i] & 0xFF) << 16         # 8 bits [23:16]
            dequant_data |= (dequant_zero[i] & 0xFF) << 24          # 8 bits [31:24]
            dequant_regfile_data.append(dequant_data)

            # Print register data for debugging
            print(f"DEQUANT CONFIG REGFILE {i}: Addr: {dequant_base_addr + i * 8:#010x}, Data: {dequant_data:#018x}")

        # Generate CONFIG REGFILE BASE ADDR
        standardization_code = textwrap.indent(textwrap.dedent(f"""
            // Standardization Unit CONFIG REGFILE
            uint64_t *quant_base = (uint64_t *)0x{quant_base_addr:08x};
            uint64_t *dequant_base = (uint64_t *)0x{dequant_base_addr:08x};\n
        """), "    ")
        # Generate QUANT REGFILE DATA
        for i in range(num_sensors):
            standardization_code += f"    *(quant_base + {i}) = 0x{quant_regfile_data[i]:016x};\n"

        # Generate DEQUANT REGFILE DATA
        for i in range(num_sensors):
            standardization_code += f"    *(dequant_base + {i}) = 0x{dequant_regfile_data[i]:016x};\n"

        self.regfile_init_code.append(standardization_code)

    def init_q_table_config(self):
        """Generate Q-table configuration initialization"""
        num_states = 512
        num_actions = 8
        q_table_0_base_addr = 0x60000018
        q_table_1_base_addr = 0x60001018

        q_table_0_value = []
        q_table_1_value = []

        for i in range(num_states):
            curr_q_value = 0
            for j in range (num_actions):
                mod_value = (i + j) % 4
                if mod_value == 0:
                    curr_q_value |= ((0x0100 + 2 * i + j * 0x0020) & 0xFFFF) << ( j * 16)
                elif mod_value == 1:
                    curr_q_value |= ((0xFF00 - i - j * 0x0025) & 0xFFFF) << ( j * 16)
                elif mod_value == 2:
                    curr_q_value |= ((0x0000) & 0xFFFF) << (j * 16)
                elif mod_value == 3:
                    curr_q_value |= ((0x0080 + i + j * 0x0010) & 0xFFFF) << (j * 16)
            q_table_0_value.append((curr_q_value & 0xFFFFFFFFFFFFFFFF))
            q_table_1_value.append((curr_q_value >> 64) & 0xFFFFFFFFFFFFFFFF)
        # Generate Q-Table 0
        q_table_code = textwrap.indent(textwrap.dedent(f"""
            // Q-Table 0 Initialization
            uint64_t *q_table_0_base = (uint64_t *)0x{q_table_0_base_addr:08x};
        """), "    ")
        for i in range(num_states):
            q_table_code += f"    *(q_table_0_base + {i}) = 0x{q_table_0_value[i]:016x};\n"

            # Print register data for debugging
            print (f"Q-Table 0 at index {i}: Addr: {q_table_0_base_addr + i * 8:#010x}, Data: {q_table_0_value[i]:#018x}")
        
        # Generate Q-Table 1
        q_table_code += textwrap.indent(textwrap.dedent(f"""
            // Q-Table 1 Initialization
            uint64_t *q_table_1_base = (uint64_t *)0x{q_table_1_base_addr:08x};
        """), "    ")
        for i in range(num_states):
            q_table_code += f"    *(q_table_1_base + {i}) = 0x{q_table_1_value[i]:016x};\n"

            # Print register data for debugging
            print (f"Q-Table 1 at index {i}: Addr: {q_table_1_base_addr + i * 8:#010x}, Data: {q_table_1_value[i]:#018x}")
        
        self.regfile_init_code.append(q_table_code)

    def init_rl_scheduler_config(self):
        """Generate RL scheduler configuration with proper indentation"""
        # RL config regfile 0
        coef_k1 = 0x1000
        coef_k2 = 0x0800
        coef_k3 = 0x0400
        learning_rate = 0x0100

        # RL config regfile 1
        discount_factor = 0x0200
        initial_epsilon = 0x0F00
        num_active_actions = 8
        thres_high = 0x50
        thres_mid = 0x30
        thres_low = 0x10

        # RL config regfile 2
        epsilon_decay_step = 0x00CC
        epsilon_min = 0x0005
        epsilon_decay_factor = 0x000A
        epsilon_decay_interval = 0x10
        epsilon_decay_mode = 0

        # Calculate register values
        # RL CONFIG REGFILE 0
        reg0 = (coef_k1 & 0xFFFF)
        reg0 |= (coef_k2 & 0xFFFF) << 16
        reg0 |= (coef_k3 & 0xFFFF) << 32
        reg0 |= (learning_rate & 0xFFFF) << 48

        # RL CONFIG REGFILE 1
        reg1 = (discount_factor & 0xFFFF)
        reg1 |= (initial_epsilon & 0xFFFF) << 16
        reg1 |= (num_active_actions & 0xFF) << 32
        reg1 |= (thres_high & 0xFF) << 40
        reg1 |= (thres_mid & 0xFF) << 48
        reg1 |= (thres_low & 0xFF) << 56

        # RL CONFIG REGFILE 2
        reg2 = (epsilon_decay_step & 0xFFFF)
        reg2 |= (epsilon_min & 0xFFFF) << 16
        reg2 |= (epsilon_decay_factor & 0xFFFF) << 32
        reg2 |= (epsilon_decay_interval & 0xFF) << 48
        reg2 |= (epsilon_decay_mode & 0x3) << 56

        # Print the register values for debugging
        rl_config_base_addr = 0x60000000
        print(f"RL CONFIG REGFILE 0: Addr: {rl_config_base_addr + 0 * 8:#010x}, Data: {reg0:#018x}")
        print(f"RL CONFIG REGFILE 1: Addr: {rl_config_base_addr + 1 * 8:#010x}, Data: {reg1:#018x}")
        print(f"RL CONFIG REGFILE 2: Addr: {rl_config_base_addr + 2 * 8:#010x}, Data: {reg2:#018x}")

        # Generate C code
        rl_scheduler_code = textwrap.indent(textwrap.dedent(f"""
            // RL Scheduler CONFIG REGFILE
            uint64_t *rl_base_addr = (uint64_t *)0x60000000;
            *(rl_base_addr + 0) = 0x{reg0:016x};  // RL config regfile 0
            *(rl_base_addr + 1) = 0x{reg1:016x};  // RL config regfile 1
            *(rl_base_addr + 2) = 0x{reg2:016x};  // RL config regfile 2
        """), "    ")
        self.regfile_init_code.append(rl_scheduler_code)

    def start_therm_top(self):
        """Start the therm_top"""
         # THERM_TOP CONFIG REGFILE 0
        therm_top_start = 1
        therm_top_en = 1
        therm_top_stop = 0
        collect_en = 1
        collect_mode = 0
        pred_en = 0
        schedule_en = 0
        store_sensor_en = 1
        store_pred_en = 0
        store_action_en = 0
        action_offset = 4
        num_itr = 10
        sampling_intvl = 200

        reg0 = (therm_top_start & 0x1)
        reg0 |= (therm_top_en & 0x1) << 1
        reg0 |= (therm_top_stop & 0x1) << 2
        reg0 |= (collect_en & 0x1) << 3
        reg0 |= (collect_mode & 0x1) << 4
        reg0 |= (pred_en & 0x1) << 5
        reg0 |= (schedule_en & 0x1) << 6
        reg0 |= (store_sensor_en & 0x1) << 7
        reg0 |= (store_pred_en & 0x1) << 8
        reg0 |= (store_action_en & 0x1) << 9
        reg0 |= (action_offset & 0x1F) << 10
        reg0 |= (num_itr & 0x1FFFF) << 15
        reg0 |= (sampling_intvl & 0xFFFFFFFF) << 32

        start_code = textwrap.indent(textwrap.dedent(f"""
            // Start the therm_top
            *(therm_top_base_addr + 0) = 0x{reg0:016x};
        """), "    ")
        self.regfile_init_code.append(start_code)

    def start_tensor_engine_wrapper(self):
        """Start tensor engine wrapper"""
        num_actions = 8
        num_instr_per_action = 4

        loop_op = 1
        local_read = 1
        l_r_op = 1
        func = 0
        cim_addr = 0
        gbuffer_addr = 0
        op_cycle = 0
        tensor_engine_instr = []
        tensor_engine_config = 0b1_0000_0000_0000_0100_0000_0001
        tensor_engine_config_addr = 0x0000_0000_4200_0000
        tensor_engine_instr_base_addr = 0x0000_0000_4100_0000

        # Generate tensor engine instructions
        for i in range(num_actions * num_instr_per_action):
            func = i % 8
            cim_addr = i % 512
            curr_tensor_engine_instr = (op_cycle & 0xF)             # 4 bits [3:0]
            curr_tensor_engine_instr |= (gbuffer_addr & 0xFFF) << 4 # 12 bits [15:4]
            curr_tensor_engine_instr |= (cim_addr & 0x1FF) << 16    # 9 bits [24:16]
            curr_tensor_engine_instr |= (func & 0x7) << 25          # 3 bits [27:25]
            curr_tensor_engine_instr |= (l_r_op & 0x3) << 28        # 2 bits [29:28]
            curr_tensor_engine_instr |= (local_read & 0x1) << 30    # 1 bit [30]
            curr_tensor_engine_instr |= (loop_op & 0x1) << 31       # 1 bit [31]
            curr_tensor_engine_instr |= 0x0 << 32                   # 1 bit [32]
            tensor_engine_instr.append(curr_tensor_engine_instr)

        start_code = textwrap.indent(textwrap.dedent(f"""
            // Start tensor_engine_wrapper
            uint64_t *tensor_engine_config_addr = (uint64_t *)0x{tensor_engine_config_addr:016x};
            uint64_t *tensor_engine_instr_base_addr = (uint64_t *)0x{tensor_engine_instr_base_addr:016x};

            // Tensor engine wrapper config
            *(tensor_engine_config_addr) = 0x{tensor_engine_config:016x};
        """), "    ")
    
        for i in range (num_actions * num_instr_per_action):
            start_code += f"    *(tensor_engine_instr_base_addr + {i}) = 0x{tensor_engine_instr[i]:016x};\n"

            # Print register data for debugging
            print(f"TENSOR_ENGINE INSTRUCTION {i}: Addr: {tensor_engine_instr_base_addr + i * 8:#010x}, Data: {tensor_engine_instr[i]:#018x}")

        print (f"TENSOR_ENGING CONFIG: Addr: {tensor_engine_config_addr:#010x}, Data: {tensor_engine_config:#018x}")
        self.regfile_init_code.append(start_code)

    def _generate_main_function(self):
        """Generate main function"""
        init_code = "\n".join(self.regfile_init_code)
        main_func_code = "int main(void) {\n"
        main_func_code += textwrap.indent(init_code, "")
        # main_func_code += textwrap.indent("\nwhile (1) {\n", "    ")
        # main_func_code += textwrap.indent("}\n", "    ")
        main_func_code += "\n    return 0;\n"
        main_func_code += "}\n"
        return main_func_code

    def generate_c_file(self, filename="/home/bwoah/tools/C_compile_template/src/main.c"):
        """Generate the complete C source file"""
        with open(filename, "w") as f:
            f.write(self.header)
            f.write(self.includes)
            f.write(self._generate_main_function())
        
        print(f"Successfully generated {filename}")

def main():
    generator = RegisterConfigGenerator()
    
    # generator.init_standardization_unit_config()
    # generator.init_rl_scheduler_config()
    # generator.init_q_table_config()

    generator.init_therm_top_config()

    # generator.start_tensor_engine_wrapper()

    generator.start_therm_top()

    generator.generate_c_file()

if __name__ == "__main__":
    main()